# Array

# Max Sum from left or right

Approach âž–

- sum from left;
- make it max sum
- start taking elements from right and decrease elements from left sum (iska rightmost element)
- check if max sum updates

```cpp
int maxScore(vector<int>& cardPoints, int k) {
        int sum=0,maxsum=0;
        for(int i=0;i<k;i++){
            sum+=cardPoints[i];
        }
        maxsum=sum;
        
        for(int i=0;i<k;i++){
            sum+=cardPoints[cardPoints.size()-1-i];
            sum-=cardPoints[k-1-i];
            if (sum>maxsum){
                maxsum=sum;
            }
        }
        return maxsum;
    }
```

# Simple map implementation

[https://practice.geeksforgeeks.org/problems/frequency-of-array-elements-1587115620/0](https://practice.geeksforgeeks.org/problems/frequency-of-array-elements-1587115620/0)

frequency count from 1 to N in an array of N elements

```cpp
void frequencyCount(vector<int>& arr,int N, int P)
    { map<int,int> x;
       for (int i=1;i<N+1;i++)
         x.insert({ i , 0});
         
         
    for (int i = 0; i < N; i++)
        x[arr[i]]++;
        
     for (int i = 0; i < N; i++)
        arr[i]=x[i+1];

  }
```

# Union or overlapping

```cpp
vector<vector<int>> merge(vector<vector<int>> &intervals)
{
    if (intervals.size() <= 1)
        return intervals;

    vector<vector<int>> ans;
    sort(intervals[0].begin(), intervals[0].end());
    ans.push_back(intervals[0]);
    for (int i = 1; i < intervals.size(); i++)
    {
        if (ans.back()[1] >= intervals[i][0])
            ans.back()[1] = max(ans.back()[1], intervals[i][1]);
        else
            ans.push_back(intervals[i]);
    }

    return ans;
}
```