# Array

# Set Row/column zeros

****SOLVE AGAIN WITHOUT USING SPACE!!!!!!!!**

My first solution➖

approach row columns in vector 

set those row column to zero.

```cpp
void setZeroes(vector<vector<int>>& matrix) {
        vector<int> r,c;
        for (int i=0;i<matrix.size();i++)
        for (int j=0;j<matrix[0].size();j++)
            if (matrix[i][j]==0)
            {r.push_back(i);
                c.push_back(j); }
       
        for (int x:r) 
        for (int j=0;j<matrix[0].size();j++)
            matrix[x][j]=0;
                for (int x:c) 
        for (int j=0;j<matrix.size();j++)
            matrix[j][x]=0;
        
        
    }
```

# Max Sum from left or right

Approach ➖

- sum from left;
- make it max sum
- start taking elements from right and decrease elements from left sum (iska rightmost element)
- check if max sum updates

```cpp
int maxScore(vector<int>& cardPoints, int k) {
        int sum=0,maxsum=0;
        for(int i=0;i<k;i++){
            sum+=cardPoints[i];
        }
        maxsum=sum;
        
        for(int i=0;i<k;i++){
            sum+=cardPoints[cardPoints.size()-1-i];
            sum-=cardPoints[k-1-i];
            if (sum>maxsum){
                maxsum=sum;
            }
        }
        return maxsum;
    }
```

# Simple map implementation

[https://practice.geeksforgeeks.org/problems/frequency-of-array-elements-1587115620/0](https://practice.geeksforgeeks.org/problems/frequency-of-array-elements-1587115620/0)

frequency count from 1 to N in an array of N elements

```cpp
void frequencyCount(vector<int>& arr,int N, int P)
    { map<int,int> x;
       for (int i=1;i<N+1;i++)
         x.insert({ i , 0});
         
         
    for (int i = 0; i < N; i++)
        x[arr[i]]++;
        
     for (int i = 0; i < N; i++)
        arr[i]=x[i+1];

  }
```

# Union or overlapping

```cpp
vector<vector<int>> merge(vector<vector<int>> &intervals)
{
    if (intervals.size() <= 1)
        return intervals;

    vector<vector<int>> ans;
    sort(intervals[0].begin(), intervals[0].end());
    ans.push_back(intervals[0]);
    for (int i = 1; i < intervals.size(); i++)
    {
        if (ans.back()[1] >= intervals[i][0])
            ans.back()[1] = max(ans.back()[1], intervals[i][1]);
        else
            ans.push_back(intervals[i]);
    }

    return ans;
}
```